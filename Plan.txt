Plan: 
- Add in Task_Manager to assign cores to different alerts
  - We are only going to be able to give two at a time so we will 
    to wait for avaible cores when we do this
  - We are going to have to open a new PostgresDB connection 
    for each core so we have to update that functionality in
    execute_updates() in our update_registry file. 


KEEP IN MIND: 
- You can have up to 15 queries running at the same
  time, so you may want to batch them in groups of 15 or
  use a Thread Pool of size 15. This would be only needed
  for updates


AI OUTPUT: 
Processing Alert_2...
AI Response for Alert_2: [TextBlock(text="Let me analyze this data and provide an interesting
insight:\n\nLooking at the data, I notice there's a significant spike in activity during 
mid-December 2024, specifically:\n\n- December 18: 321 (units/transactions)\n- December 19:
460 (units/transactions)\n- December 20: 289 (units/transactions)\n\nThis three-day period 
shows unusually high activity compared to the rest of the dataset, where most daily values 
range between -10 to +25. This could indicate:\n1. A major event or deadline\n2. End-of-year
activity surge\n3. Possible seasonal pattern\n\nThis spike also coincides with the highest 
price/value levels in the dataset (around 104.5-104.7), suggesting this period might be 
particularly significant for whatever metric is being measured.\n\nWould you like me to 
analyze any other aspects of this data?", type='text')]


TEST INPUTS: 
--------------------------------------------------------------------------------------------------

{'block_timestamp' : 'TIMESTAMP', 'net_holders' : 'int', 'price' : 'numeric'}

--------------------------------------------------------------------------------------------------

with tab1 as (
  SELECT 
    tx_id,
    mint_amount / power(10, 9) as amt
  from solana.defi.fact_token_mint_actions
  where mint LIKE 'CRTx1JouZhzSU6XytsE42UQraoGqiHgxabocVfARTy2s'
  and block_timestamp > '2024-05-01'
)

, Carrot_Price as ( 
SELECT 
  date(block_timestamp) as day,
  median(amount/amt) as median_price

FROM solana.core.fact_transfers as a
  left outer join tab1
    on a.tx_id = tab1.tx_id  
where tx_to like 'FfCRL34rkJiMiX5emNDrYp3MdWH2mES3FvDQyFppqgpJ'
and mint like 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'
and block_timestamp > '2024-05-01'
GROUP BY 1 
having not median_price = 0
order by 1 
) 

, Carrot_Holders as (
SELECT
  date(block_timestamp) as day,
  sum(
    case when bal = 0 then -1 
    when  change = bal then 1 
    else 0 end
  ) as net_holders

FROM (
SELECT
  block_timestamp,
  owner,
  balance - pre_balance as change,
  sum(balance - pre_balance) over (partition by owner ORDER by block_id) as bal

FROM solana.core.fact_token_balances
WHERE mint = 'CRTx1JouZhzSU6XytsE42UQraoGqiHgxabocVfARTy2s'
  AND succeeded = TRUE
  AND block_timestamp::date >= '2024-08-01'
)
group by 1 
ORDER BY 1 
) 

select
Carrot_Price.day as block_timestamp, 
net_holders,
median_price as price
from Carrot_Price left outer join Carrot_Holders on 
Carrot_Price.day = Carrot_Holders.day
END

--------------------------------------------------------------------------------------------------

with tab1 as (
  SELECT 
    tx_id,
    mint_amount / power(10, 9) as amt
  from solana.defi.fact_token_mint_actions
  where mint LIKE 'CRTx1JouZhzSU6XytsE42UQraoGqiHgxabocVfARTy2s'
  and block_timestamp > '2024-05-01'
)

, Carrot_Price as ( 
SELECT 
  date(block_timestamp) as day,
  median(amount/amt) as median_price

FROM solana.core.fact_transfers as a
  left outer join tab1
    on a.tx_id = tab1.tx_id  
where tx_to like 'FfCRL34rkJiMiX5emNDrYp3MdWH2mES3FvDQyFppqgpJ'
and mint like 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v'
and block_timestamp > '2024-05-01'
and block_timestamp > current_date - 2 
GROUP BY 1 
having not median_price = 0
order by 1 
) 

, Carrot_Holders as (
SELECT
  date(block_timestamp) as day,
  sum(
    case when bal = 0 then -1 
    when  change = bal then 1 
    else 0 end
  ) as net_holders

FROM (
SELECT
  block_timestamp,
  owner,
  balance - pre_balance as change,
  sum(balance - pre_balance) over (partition by owner ORDER by block_id) as bal

FROM solana.core.fact_token_balances
WHERE mint = 'CRTx1JouZhzSU6XytsE42UQraoGqiHgxabocVfARTy2s'
  AND succeeded = TRUE
  AND block_timestamp::date >= '2024-08-01'
)
Where block_timestamp > current_date - 2 
group by 1 
ORDER BY 1 
) 

select
Carrot_Price.day as block_timestamp, 
net_holders,
median_price as price
from Carrot_Price left outer join Carrot_Holders on 
Carrot_Price.day = Carrot_Holders.day
END

--------------------------------------------------------------------------------------------------
import multiprocessing
import psutil
import os
import time
from alert_processor import AlertProcessor

class CoreTaskManager:
    def __init__(self, max_cores=2):
        """
        Initializes the CoreTaskManager with core management logic.
        :param max_cores: Maximum number of cores to use.
        """
        self.core_states = {i: None for i in range(max_cores)}  # Track core states

    def set_core_affinity(self, process, core_id):
        """
        Set core affinity for a process.
        :param process: The process to assign.
        :param core_id: The core ID to assign the process to.
        """
        ps_process = psutil.Process(process.pid)
        ps_process.cpu_affinity([core_id])  # Restrict to a single core

    def worker(self, alert_name, metadata, core_id):
        """
        Worker function to process an alert.
        :param alert_name: The name of the alert being processed.
        :param metadata: The metadata for the alert.
        :param core_id: The core the task is assigned to.
        """
        print(f"Processing alert '{alert_name}' on core {core_id} (Process ID: {os.getpid()})")
        processor = AlertProcessor()
        triggered_alert = {alert_name: metadata}
        processor.process_alert(triggered_alert)
        print(f"Alert '{alert_name}' completed on core {core_id}")

    def run_alerts(self, alerts):
        """
        Run alerts with core assignment and management.
        :param alerts: Dictionary of alerts with metadata.
        """
        for alert_name, metadata in alerts.items():
            while True:
                # Check for free cores
                for core_id, process in self.core_states.items():
                    if process is None or not process.is_alive():
                        # If the core is free, start a new process
                        p = multiprocessing.Process(target=self.worker, args=(alert_name, metadata, core_id))
                        print(f"Starting process for {alert_name} on core {core_id}")
                        p.start()
                        self.set_core_affinity(p, core_id)
                        self.core_states[core_id] = p
                        break
                else:
                    # No cores are free, wait for one to become available
                    time.sleep(1)
                    continue
                break

        # Ensure all tasks are completed
        for core_id, process in self.core_states.items():
            if process:
                process.join()

        print("âœ… All alerts processed.")
